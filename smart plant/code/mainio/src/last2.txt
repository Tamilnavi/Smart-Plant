#include <Wire.h>
#include <Adafruit_BMP085.h>
#include <U8g2lib.h>
#include <RTClib.h>
#include <DHT.h>
#include <DFRobotDFPlayerMini.h>



// Initialize Display (I2C)
U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
// BMP180 Sensor
Adafruit_BMP085 bmp;
// RTC
RTC_DS3231 rtc;

#define LDR 12  // LDR Sensor Pin
#define BUZZER 5  // Define buzzer pin
#define DHTPIN 14       // DHT11 sensor connected to pin 14
#define DHTTYPE DHT11   // DHT11 sensor type
DHT dht(DHTPIN, DHTTYPE);
#define CSM 34 // capacitive soil moisture
#define TANK 35 // water level

#define DFPLAYER_RX 16 // ESP32 RX pin connected to DFPlayer TX
#define DFPLAYER_TX 17 // ESP32 TX pin connected to DFPlayer RX
HardwareSerial mySerial(2); // Using Serial2 for DFPlayer
DFRobotDFPlayerMini myDFPlayer;

bool buzzerActive = false;
unsigned long buzzerStartTime = 0;
const long buzzerDuration = 500;  // Buzzer beeps for 500ms
String moi_lvl = "Watered";
String tank_flow = "Low";


// Mode control
enum DisplayMode { TIME_MODE, DATE_MODE, LDR_MODE, HUM_MODE, TEMP_MODE, PH_MODE, CSM_MODE, TANK_MODE };
DisplayMode mode = TIME_MODE;

// Timing variables
unsigned long previousMillis = 0;
unsigned long modeStartTime = 0;
const long timeInterval = 5000;  // Time Mode runs for 5 sec
const long dateInterval = 3000;  // Date Mode runs for 3 sec
const long ldrInterval = 2000;   // LDR Mode runs for 2 sec

// ðŸ“Œ Function to display text on OLED
// void displayText(const char* text) {
//     u8g2.clearBuffer();
//     u8g2.setFont(u8g2_font_10x20_tr);
//     u8g2.drawStr(10, 20, text);
//     u8g2.sendBuffer();
// }
void displayText(const char* text) {
    u8g2.clearBuffer();  // Clear the display buffer
  
    const uint8_t* fonts[] = {
      u8g2_font_10x20_tr,
      u8g2_font_7x14_tr,
      u8g2_font_6x10_tr,
      u8g2_font_5x8_tr
    };  // Font options in decreasing size
  
    int16_t maxWidth = 128;  // OLED width
    int16_t maxHeight = 32;  // OLED height
    int16_t lineHeight = 0;
  
    const uint8_t* selectedFont = fonts[0];
    int linesNeeded = 1;
  
    // Find the largest font that fits the display
    for (size_t i = 0; i < sizeof(fonts) / sizeof(fonts[0]); i++) {
      u8g2.setFont(fonts[i]);
      lineHeight = u8g2.getFontAscent() - u8g2.getFontDescent() + 1;
  
      // Simulate word wrapping to calculate lines needed
      char buffer[256];
      strncpy(buffer, text, sizeof(buffer));
      char* word = strtok(buffer, " ");
      char line[128] = "";
      linesNeeded = 1;
  
      while (word) {
        char tempLine[128];
        snprintf(tempLine, sizeof(tempLine), "%s%s%s", line, strlen(line) > 0 ? " " : "", word);
  
        if (u8g2.getStrWidth(tempLine) > maxWidth) {
          linesNeeded++;
          strncpy(line, word, sizeof(line));
        } else {
          strncpy(line, tempLine, sizeof(line));
        }
        word = strtok(nullptr, " ");
      }
  
      if (linesNeeded * lineHeight <= maxHeight) {
        selectedFont = fonts[i];
        break;
      }
    }
  
    // Set the selected font
    u8g2.setFont(selectedFont);
  
    // Word wrapping and rendering
    char buffer[256];
    strncpy(buffer, text, sizeof(buffer));
    char* word = strtok(buffer, " ");
    char line[128] = "";
    int16_t y = (maxHeight - (linesNeeded * lineHeight)) / 2 + lineHeight;
  
    while (word) {
      char tempLine[128];
      snprintf(tempLine, sizeof(tempLine), "%s%s%s", line, strlen(line) > 0 ? " " : "", word);
  
      if (u8g2.getStrWidth(tempLine) > maxWidth) {
        u8g2.drawStr((maxWidth - u8g2.getStrWidth(line)) / 2, y, line);
        y += lineHeight;
        strncpy(line, word, sizeof(line));
      } else {
        strncpy(line, tempLine, sizeof(line));
      }
      word = strtok(nullptr, " ");
    }
  
    if (strlen(line) > 0) {
      u8g2.drawStr((maxWidth - u8g2.getStrWidth(line)) / 2, y, line);
    }
  
    u8g2.sendBuffer();  // Update the display
  }
  

// Function to play a specific sound
void playSound(int track) {
    int playerState = myDFPlayer.readState();
    if (playerState != 1) { // If player is not playing
      myDFPlayer.play(track); // Play the specified track   
    }
}
  
// ðŸ“Œ Function to display Time
void displayTime() {
    DateTime now = rtc.now();
    String timeStr = String(now.hour()) + ":" + String(now.minute()) + ":" + String(now.second());
    displayText(timeStr.c_str());
}

// ðŸ“Œ Function to display Date
void displayDate() {
    DateTime now = rtc.now();
    String dateStr = String(now.day()) + "-" + String(now.month()) + "-" + String(now.year());
    displayText(dateStr.c_str());
}

// ðŸ“Œ Function to display LDR Light Level
void displayLDR() {
    int lightLevel = analogRead(LDR);
    String ldrStr = "LDR: " + String(map(lightLevel,100,4000,0,100));

    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_10x20_tr);
    u8g2.drawStr(10, 20, ldrStr.c_str());

    // Light bulb icon (simple representation)
    u8g2.drawCircle(100, 15, 6, U8G2_DRAW_ALL);  // Bulb top
    u8g2.drawBox(97, 20, 6, 3);                 // Bulb base

    u8g2.sendBuffer();
    playSound(2);
}

void displayHUM() {
    float humidity = dht.readHumidity();
    String hum_text = "Hum: " + String(humidity) + "%";
    displayText(hum_text.c_str()); // Show Humidity with icon
}
void displayTEMP() {
    float temperature = bmp.readTemperature();
    String temp_text = "Tmp: " + String(temperature)+"`C";
    displayText(temp_text.c_str()); // Show Temp icon
    myDFPlayer.stop();
}
void displayPH(){
    float pressure = bmp.readPressure() / 100.0;  // Convert Pa to hPa
    String press_text = String(pressure) + " hPa";
    displayText(press_text.c_str()); // Show Temp & Pressure with icon
}
void displayCSM(){
    int moisture = analogRead(CSM);
    if (moisture <= 520 && moisture > 430 ){
        moi_lvl = "Watered";
    }
    else if (moisture <= 430 && moisture > 350){
        moi_lvl = "Wet";
    }
    else if (moisture <= 350 && moisture > 260){
        moi_lvl = "Dry";
    }
    String moi_text = "Soil moi: "+String(map(moisture,260,520,0,100))+"%";
    displayText(moi_text.c_str());
}
void displayTANK(){
    float tank_lvl = analogRead(TANK);
    if (tank_lvl <= 520 && tank_lvl > 420){
        tank_flow = "HIGH";
        
    }
    else if (tank_lvl < 120){
        tank_flow = "LOW";
        String tank_text = "Tank lvl "+ tank_flow;
        displayText(tank_text.c_str());
    }
}

void setup() {
    pinMode(LDR, INPUT);
    pinMode(CSM, INPUT);
    pinMode(TANK, INPUT);
    Serial.begin(115200);
    Wire.begin();
    u8g2.begin();  // Initialize OLED Display
    dht.begin();


    pinMode(BUZZER, OUTPUT);
    digitalWrite(BUZZER, LOW);  // Ensure buzzer starts OFF


    // Initialize BMP180 Sensor
    if (!bmp.begin()) {
        Serial.println("Could not find BMP180 sensor!");
        while (1);
    }
    
    // Initialize RTC
    if (!rtc.begin()) {
        Serial.println("Couldn't find RTC!");
    }

      // Initialize DFPlayer Mini
    mySerial.begin(9600, SERIAL_8N1, DFPLAYER_RX, DFPLAYER_TX);
    if (!myDFPlayer.begin(mySerial)) {
        Serial.println("DFPlayer Mini initialization failed!");
        while (true); // Halt if DFPlayer fails to initialize
    }
    myDFPlayer.volume(30);

    displayText("HI");
    delay(1000);
    // myDFPlayer.play(2);
    modeStartTime = millis();  // Start the first mode
}

void loop() {
    DateTime now = rtc.now();

    // Check if a new hour has started
    if (now.minute() == 0 && now.second() == 0 ) {
        // lastHour = currentHour;  // Update lastHour
        digitalWrite(BUZZER, HIGH);
        buzzerActive = true;
        buzzerStartTime = millis();  // Start the buzzer timer
    }
    
    // Turn off the buzzer after 500ms
    if (buzzerActive && millis() - buzzerStartTime >= buzzerDuration) {
        digitalWrite(BUZZER, LOW);
        buzzerActive = false;  // Reset the buzzer flag
    }

    unsigned long currentMillis = millis();

    // Change mode based on time intervals
    if (mode == TIME_MODE && currentMillis - modeStartTime >= timeInterval) {
        mode = DATE_MODE;
        modeStartTime = currentMillis;
    } 
    else if (mode == DATE_MODE && currentMillis - modeStartTime >= dateInterval) {
        mode = LDR_MODE;
        modeStartTime = currentMillis;
    } 
    else if (mode == LDR_MODE && currentMillis - modeStartTime >= ldrInterval) {
        mode = HUM_MODE;
        modeStartTime = currentMillis;
    }
    else if (mode == HUM_MODE && currentMillis - modeStartTime >= ldrInterval) {
        mode = TEMP_MODE;
        modeStartTime = currentMillis;
    }
    else if (mode == TEMP_MODE && currentMillis - modeStartTime >= ldrInterval) {
        mode = PH_MODE;
        modeStartTime = currentMillis;
    }
    else if (mode == PH_MODE && currentMillis - modeStartTime >= ldrInterval) {
        mode = CSM_MODE;
        modeStartTime = currentMillis;
    }
    else if (mode == CSM_MODE && currentMillis - modeStartTime >= ldrInterval) {
        mode = TANK_MODE;
        modeStartTime = currentMillis;
    }
    else if (mode == TANK_MODE && currentMillis - modeStartTime >= ldrInterval) {
        mode = TIME_MODE;
        modeStartTime = currentMillis;
    }

    // Call the function based on the mode
    if (mode == TIME_MODE) {
        displayTime();
    } 
    else if (mode == DATE_MODE) {
        displayDate();
    } 
    else if (mode == LDR_MODE) {
        displayLDR();
    }
    else if (mode == HUM_MODE){
        displayHUM();
    }
    else if (mode == TEMP_MODE){
        displayTEMP();
    }
    else if (mode == PH_MODE){
        displayPH();
    }
    else if (mode == CSM_MODE){
        displayCSM();
    }
    else if (mode == TANK_MODE){
        displayTANK();
    }


    delay(1000);  // Avoid flickering
}


